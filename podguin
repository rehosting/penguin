#!/usr/bin/env bash

set -eu

# Function to check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

BOLD=""
RESET=""
RED=""
GREEN=""
# Check if we're in a terminal and if it supports colors
if [ -t 1 ] && [ -n "$TERM" ] && command_exists tput && tput setaf 1 >/dev/null 2>&1; then
    ncolors=$(tput colors)
    if [ -n "$ncolors" ] && [ $ncolors -ge 8 ]; then
        # Terminal supports at least 8 colors
        BOLD=$(tput bold)
        RESET=$(tput sgr0)
        RED=$(tput setaf 1)
        GREEN=$(tput setaf 2)
    fi
fi

# Function to generate a random network name
generate_network_name() {
    echo "nw_$RANDOM"
}

# Try to create a network sequentially from 0 to 255
create_dynamic_network() {
    local base="192.168"
    
    # Iterate through all 256 possible subnets in the 192.168.x.x block
    for i in {0..255}; do
        local candidate_subnet="$base.$i.0/24"
        local candidate_gateway="$base.$i.1"
        # We still use a random name to avoid name collisions with old/stale networks
        local candidate_name="nw_$RANDOM" 
        
        # Try to create the network
        # >/dev/null silences the network name on success
        # 2>/dev/null silences the error message on failure (collision)
        if podman network create --driver bridge --subnet="$candidate_subnet" --gateway="$candidate_gateway" "$candidate_name" >/dev/null 2>/dev/null; then
            # Success! Export the variables for the main script to use
            subnet="$candidate_subnet"
            network_name="$candidate_name"
            gateway="$candidate_gateway"
            ip="$base.$i.2"
            return 0
        fi
    done

    echo "Failed to create a network. Checked all subnets from 192.168.0.0/24 to 192.168.255.0/24." >&2
    exit 1
}

penguin_run() {
    local cmd=()
    local maps=()
    local build=false
    local build_singularity=false
    local pydev=false
    local verbose=false
    local reproduce=false
    local shell_mode=false
    local subnet=""
    local container_name="" # Name of the instance
    local image="rehosting/penguin" # Container to run
    local extra_docker_args=""

    # Process each command-line argument
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --wrapper-help)
                echo "Usage: penguin [WRAPPER FLAGS] [COMMAND] [ARGS]"
                echo "Wrapper script for running PENGUIN in a Podman container"
                echo ""
                echo "Wrapper-specific flags may be passed in *before* the PENGUIN command. If a value is required, it must be specified immediately after the flag with a space."
                echo "  --build: Build the PENGUIN container before running the specified command. If no command is specifed, just build and exit"
                echo "  --build-singularity: Build the PENGUIN container and then convert it to singularity. No command will be run"
                echo "  --pydev: Map local python package and plugin code into container and reinstall before running the specified command."
                echo "  --subnet: IP subnet to use. For example --subnet 192.168.0.0/24 would produce a network with firmware reachable at 192.168.0.2."
                echo "            Default: automatically find next free /24 subnet in 192.168.x.x"
                echo "            Set to 'none' to disable network creation."
                echo "  --name: A name to identify the penguin container. By default based on project directory (if available)"
                echo "  --image: Which image to run. Default: rehosting/penguin"
                echo "  --extra_docker_args: Extra arguments to pass to podman. For example --extra_docker_args \"-p 8000:80\" to expose container port 80 on host port 8000."
                echo "  --verbose: Print verbose output for penguin wrapper (e.g., filesystem mappings, podman command)"
                echo "  --wrapper-help: this message"
                echo ""
                echo "All other arguments will be passed through to the main PENGUIN command in the container."
                echo "For example try:"
                echo "  penguin --help"
                echo "  penguin init --help"
                echo "  penguin run --help"
                exit 0
                ;;
            --build)
                build=true
                shift
                ;;
            --build-singularity)
                build_singularity=true
                shift
                ;;
            --pydev)
                pydev=true
                shift
                ;;
            --subnet)
                subnet="$2"
                shift 2
                ;;
            --name)
                container_name="$2"
                shift 2
                ;;
            --image)
                image="$2"
                shift 2
                ;;
            --extra_docker_args)
                extra_docker_args="$2"
                shift 2
                ;;
            --verbose)
                verbose=true
                shift
                ;;
            *)  # Default case: If no more known options, keep as part of command
                cmd=("$@")
                break
                ;;
        esac
    done
    # If command is empty, parse any un-shifted args into array - probably means we were run with wrapper flags only
    if [[ ${#cmd[@]} -eq 0 ]]; then
        cmd=("$@")
    fi

    # If verbose, log all wrapper args and command
    if $verbose; then
        echo "${BOLD}Wrapper args:${RESET}"
        echo "  build: $build"
        echo "  build_singularity: $build_singularity"
        echo "  pydev: $pydev"
        echo "  subnet: $subnet"
        echo "  name: $container_name"
        echo "  extra_docker_args: $extra_docker_args"
        echo "  verbose: $verbose"
        echo "  penguin cmd: ${cmd[*]}"
        echo
    fi

    # Handle special case for "init" command by ensuring ./projects is mapped if no output directory is specified
    if [[ ${#cmd[@]} -gt 1 && "${cmd[0]}" == "init" && ! "${cmd[1]}" == "--help" && ! " ${cmd[@]} " =~ " --output " ]]; then
        if [ ! -d "projects" ]; then
            mkdir "projects"
        fi
        maps+=("$(pwd)/projects:/host_projects")
        cmd+=("--output_base")
        cmd+=("/host_projects")
    fi

    if [[ ${#cmd[@]} -gt 1 && ("${cmd[0]}" == "reproduce" || "${cmd[0]}" == "repro" )]]; then
        if [[ ${#cmd[@]} -lt 2 ]]; then
            echo "Reproduce command requires a specific image to be passed as the first argument. Please set --image to the image you want to use."
            exit 1
        fi

        if $pydev; then
            echo "Reproduce command does not support --pydev flag. Please remove it."
            exit 1
        fi

        image="${cmd[1]}"
        reproduce=true
    fi


    # Check for "--output" flag and create the specified directory if it doesn't exist
    for ((i=1; i<${#cmd[@]}; i++)); do
        if [[ "${cmd[$i]}" == "--output" && $((i+1)) -lt ${#cmd[@]} ]]; then
            output_dir="${cmd[$i+1]}"
            if [[ ! -d "$output_dir" ]]; then
                mkdir -p "$output_dir"
            fi
        fi
    done

    # Create mappings for existing paths
    paths=("${cmd[@]:1}")
    for arg in "${paths[@]}"; do
        if [[ -e "$arg" ]]; then
            local abspath=$(realpath "$arg")
            local host_path=$(dirname "$abspath")
            local guest_path="/host_$(basename "$host_path")"

            maps+=("$host_path:$guest_path")
        fi
    done

    # If pydev mode we need to also map ./pkg to /pkg
    if $pydev; then
        maps+=("$(pwd)/src:/pkg")
        maps+=("$(pwd)/pyplugins:/pandata")
    fi

    # Sort mappings by path length
    IFS=$'\n' maps=($(sort -r <<<"${maps[*]}"))
    unset IFS

    # Rewrite paths
    new_cmd=()
    if [[ ${#cmd[@]} -gt 0 ]]; then
        new_cmd+=("${cmd[0]}") # Never rewrite the first arg (penguin subcommand: init/run/patch/etc)
    fi
    for ((i=1; i<${#cmd[@]}; i++)); do
        arg="${cmd[$i]}"
        local rewritten=false

        # Skip rewriting if this argument is one of our flags
        if [[ $i -gt 1 && "${cmd[$((i-1))]}" =~ ^--(timeout|config|output|name|image|subnet|extra_docker_args)$ ]]; then
            new_cmd+=("$arg")
            continue
        fi

        # Skip rewriting if this is a flag itself
        if [[ "$arg" =~ ^-- ]]; then
            new_cmd+=("$arg")
            continue
        fi

        # Only attempt path rewriting if the argument actually exists as a file/directory
        if [[ -e "$arg" ]]; then
            for map in "${maps[@]}"; do
                local host_path="${map%%:*}"
                local guest_path="${map#*:}"

                # Check if the real directory path of the argument matches the host path
                local real_arg_path="$(realpath "$arg" 2>/dev/null)"
                if [[ "$real_arg_path" == "$host_path"* ]]; then
                    local rewritten_path="${real_arg_path//$host_path/$guest_path}"
                    new_cmd+=("$rewritten_path")
                    rewritten=true
                    break
                fi
            done
        fi

        if ! $rewritten; then
            new_cmd+=("$arg")
        fi
    done

    if $verbose; then
        echo "${BOLD}Mappings from host paths to guest paths: $RESET"
        for map in "${maps[@]}"; do
            echo "  $map"
        done
        echo
    fi


     # Build Podman command
     # Note: --security-opt label=disable is required for Podman to access mapped volumes on SELinux systems
    docker_cmd=("podman" "run" "--rm" "--security-opt" "label=disable")

    # If we have a name set, ensure it's available. We only really care about this for run/guest_cmd/shell (and maybe explore) action
    if [[ ${#cmd[@]} -gt 1 && ( "${cmd[0]}" == "run" || "${cmd[0]}" == "guest_cmd" || "${cmd[0]}" == "shell" ) ]]; then
        if [ -z "$container_name" ]; then
            # No name set - try to grab it - find last argument with host path and use that
            for ((i=${#cmd[@]}-1; i>0; i--)); do
                # Check if it's a directory or file
                if [[ -e "${cmd[$i]}" ]]; then
                    potential_name=$(basename "${cmd[$i]}")
                    # If potential name is config.yaml or starts with a number try up a level
                    # or config.yaml
                    if [[ $potential_name =~ ^[0-9] ]] || [[ $potential_name =~ \.yaml$ ]]; then
                        # Take the dirname then basename
                        potential_name=$(basename "$(dirname "${cmd[$i]}")")
                        if [[ $potential_name =~ ^[0-9] || $potential_name =~ \.yaml$ ]]; then
                            # Still bad - skip
                            continue
                        fi
                    fi

                    # Filter out any non alpha numeric characters
                    potential_name=$(echo "$potential_name" | tr -cd '[:alnum:]')

                    # If potential name is empty after filtering, skip
                    if [ -z "$potential_name" ]; then
                        continue
                    fi

                    container_name=$potential_name
                    if $verbose; then
                        echo "${BOLD}Calculated name for container: ${GREEN}$container_name${RESET}"
                        echo
                    fi
                    break
                fi
            done
        else
            if $verbose; then
                echo "${BOLD}Using provided for container: ${GREEN}$container_name${RESET}"
                echo
            fi
        fi

        if [[ -n "$container_name" && "${cmd[0]}" != "guest_cmd" && "${cmd[0]}" != "shell" ]]; then
            if podman ps --all --format '{{.Names}}' | grep -q "^$container_name$"; then
                echo "${BOLD}ERROR: Container name ${RED}$container_name${RESET}${BOLD} is already in use!${RESET}"
                echo "  Please specify a different name with ${BOLD}--name${RESET}"
                exit 1
            fi
            # Unique name - add it to command
            docker_cmd+=("--name" "$container_name")
        fi
    fi

    # If we are running a command in the guest, we want to podman exec then bail
    if [[ ${#cmd[@]} -gt 1 && "${cmd[0]}" == "guest_cmd" ]]; then
        # Filter out any file/directory arguments that were used for container naming
        guest_cmd_args=()
        for ((i=1; i<${#cmd[@]}; i++)); do
            if [[ ! -e "${cmd[$i]}" ]]; then
                guest_cmd_args+=("${cmd[$i]}")
            fi
        done

        docker_cmd=("podman" "exec" "-it" "${container_name}" "python3" "/igloo_static/guesthopper/guest_cmd.py" "${guest_cmd_args[@]}")
        "${docker_cmd[@]}"
        exit $?
    fi

    # Similarly if we are running a shell in the container, start it if it's not already running, otherwise exec into that container
    if [[ ${#cmd[@]} -gt 1 && ( "${cmd[0]}" == "shell" ) ]]; then
        # Check if container is running
        if [[ -n "$container_name" ]] && podman ps --format '{{.Names}}' | grep -q "^$container_name$"; then
            # Container is running, exec into it and bail
            docker_cmd=("podman" "exec" "-it" "${container_name}" "bash")
            "${docker_cmd[@]}"
            exit $?
        else
            # Container is not running, we need to start it
            # We'll continue with the normal podman run flow but override the command to be bash
            shell_mode=true
        fi
    fi

    # Check if we're in an interactive terminal, if so add -it
    if [ -t 0 ]; then
        docker_cmd+=("-it")
    fi

    # Dynamic network
    if [ "$subnet" != "none" ]; then
        if [ -z "$subnet" ]; then
            # CASE A: No subnet specified, auto-discover
            create_dynamic_network
            # Note: create_dynamic_network sets $network_name, $subnet, $gateway, and $ip
        else
            # CASE B: User specified a subnet manually
            network_name=$(generate_network_name)
            gateway="${subnet%.*}.1"
            ip="${subnet%.*}.2"
            
            # Try to create user's specific subnet. If this fails, we must exit (user asked for specific config)
            if ! podman network create --driver bridge --subnet=$subnet --gateway=$gateway $network_name >/dev/null; then
                echo "Error: Failed to create user-specified subnet $subnet"
                exit 1
            fi
        fi

        # Setup  on-exit cleanup
        trap "podman network rm $network_name >/dev/null 2>&1" EXIT

        docker_cmd+=("--network" "$network_name" "--ip" "$ip")
        # Add env variable CONTAINER_IP=ip
        docker_cmd+=("-e" "CONTAINER_IP=$ip")

        if $verbose; then
            echo "${BOLD}Podman network setup:${RESET}"
            echo "  Network name: $network_name"
            echo "  Subnet: $subnet"
            echo "  Gateway: $gateway"
            echo "  Container IP: $ip"
            echo
        fi
    else
        if $verbose; then
            echo "${BOLD}Podman network setup:${RESET}"
            echo "  Skipped due to --subnet none flag"
            echo
        fi
    fi

    # Add penguin bash script hash environment variable
    hash=$(sha256sum "$0" | awk '{print $1}')
    docker_cmd+=("-e" "PENGUIN_HASH=$hash")

    # Add container name if set
    if [ -n "$container_name" ]; then
        docker_cmd+=("-e" "CONTAINER_NAME=$container_name")
    fi

    project_dir=""
    for ((i=${#cmd[@]}-1; i>0; i--)); do
        if [[ -e "${cmd[$i]}" ]]; then
            local host_realpath=$(realpath "${cmd[$i]}")
            if [[ -f "$host_realpath" ]]; then
                host_realpath=$(dirname "$host_realpath")
            fi

            # Convert host path to container path using same logic as mappings
            local host_parent=$(dirname "$host_realpath")
            local container_path="/host_$(basename "$host_parent")"
            local relative_path="${host_realpath#$host_parent/}"

            # If the relative path is empty (i.e., we're at the mapped directory), use just the container path
            if [ -z "$relative_path" ] || [ "$relative_path" = "$host_realpath" ]; then
                project_dir="$container_path"
            else
                project_dir="$container_path/$relative_path"
            fi
            break
        fi
    done
    if [ -n "$project_dir" ]; then
        docker_cmd+=("-e" "PENGUIN_PROJECT_DIR=$project_dir")
        if $verbose; then
            echo "${BOLD}Setting environment variables:${RESET}"
            echo "  PENGUIN_PROJECT_DIR=$project_dir"
            echo
        fi
    fi

    # Add mappings to podman command
    for map in "${maps[@]}"; do
        docker_cmd+=("-v" "$map")
    done

    # Add extra args, if set
    if [ -n "$extra_docker_args" ]; then
        docker_cmd+=($extra_docker_args)
    fi

    if $build_singularity; then
        build=true
    fi

    if $build; then
        echo "Running with container rebuild (--build). Entire container will be rebuilt."
        # Rebuild container
        if [ ! -f "Dockerfile" ]; then
            echo "Dockerfile not found in current directory and you requested a container rebuild"
            exit 1
        fi
        if [ ! "$(basename "$(pwd)")" == "penguin" ]; then
            echo "Current directory is not named penguin and you requested a container rebuild"
            exit 1
        fi

        if [ -n "${SSH_AUTH_SOCK:-}" ]; then
            podman build --build-arg SSH=1 --ssh default -t $image -t rehosting/fw2tar .
        else
            podman build -t $image -t rehosting/fw2tar .
        fi

        if [[ ${#new_cmd[@]} -eq 0 && $build_singularity == false ]]; then
            echo "$image built. Exiting as no command was specified."
            exit 0
        fi
    fi

    if $build_singularity; then
        rm -rf .singularity || true
        mkdir -p .singularity
        
        # Determine socket location for podman
        PODMAN_SOCK=""
        if [ -S "${XDG_RUNTIME_DIR:-}/podman/podman.sock" ]; then
            PODMAN_SOCK="${XDG_RUNTIME_DIR}/podman/podman.sock"
        elif [ -S "/run/podman/podman.sock" ]; then
            PODMAN_SOCK="/run/podman/podman.sock"
        fi
        if [ -z "$PODMAN_SOCK" ]; then
             echo "Warning: Could not find podman.sock, defaulting to /var/run/docker.sock"
             PODMAN_SOCK="/var/run/docker.sock"
        fi

        podman run -v "$PODMAN_SOCK:/var/run/docker.sock" \
            -v $(pwd)/.singularity:/output \
            --privileged -t \
            --security-opt label=disable \
            --rm quay.io/singularity/docker2singularity:v3.9.0 \
            rehosting/penguin
        mv -f .singularity/rehosting_penguin*.sif penguin.sif
        rm -rf .singularity || true
        echo "penguin.sif built"
        exit 0
    fi

    # Main run logic
    # We rely on Podman Rootless default mapping:
    #   Container Root (UID 0)  -> Host User (UID 1000)
    #   Container User (UID 1000) -> Host Subuid (UID 100000+)
    # By running as root inside (default), 'tar' can preserve ownership (0:0),
    # which results in files being owned by the Host User.
    # We DO NOT use -u or --userns=keep-id.

    docker_cmd+=("--cap-add=NET_BIND_SERVICE")
    docker_cmd+=("$image")

    if $pydev; then
        echo "Running in Python development mode (--pydev). Python package will be reinstalled on each run"
        # Since we run as root inside, we can just install and run.
        docker_cmd+=("/bin/bash" "-c" "pip install -e /pkg &>/tmp/log.txt || { cat /tmp/log.txt; exit 1; }; penguin ${new_cmd[*]@Q}")
    else
        # reproduce runs the default commmand
        if ! $reproduce; then
            if $shell_mode; then
                docker_cmd+=("bash")
            else
                docker_cmd+=("penguin")
                docker_cmd+=("${new_cmd[@]}")
            fi
        fi
    fi

    if $verbose; then
        echo "${BOLD}PENGUIN command:${RESET}"
        echo "  penguin ${new_cmd[@]}"
        echo
        echo "${BOLD}Complete podman commands:${RESET}"
        if [ "$subnet" != "none" ]; then
            echo "  podman network create -d bridge --subnet=$subnet --gateway=$gateway $network_name"
        fi
        echo "  ${docker_cmd[*]}"
        echo
        echo "${BOLD}Command output:${RESET}"
    fi

    # Execute Podman command
    "${docker_cmd[@]}"
}

# Main function
main() {
    penguin_run "$@"
}

main "$@"